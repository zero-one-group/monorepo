package dummy

import (
	"log/slog"
	"os"

	"go-modular/modules/dummy/handler"
	"go-modular/modules/dummy/repository"
	"go-modular/modules/dummy/services"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/labstack/echo/v4"
)

type Options struct {
	PgPool *pgxpool.Pool
	Logger *slog.Logger
}

// DummyModule holds dependencies for dummy-related handlers.
type DummyModule struct {
	logger      *slog.Logger
	middlewares []echo.MiddlewareFunc
	handler     *handler.Handler
}

// NewModule creates a new DummyModule.
func NewModule(opts *Options) *DummyModule {
	logger := opts.Logger
	if logger == nil {
		logger = slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{}))
	}

	// Initialize required services
	dummyService := services.NewDummyService(services.DummyServiceOpts{
		DummyRepo: repository.NewDummyRepository(opts.PgPool, logger),
	})

	h := handler.NewHandler(&handler.HandlerOpts{
		Logger:       logger,
		DummyService: dummyService,
	})

	return &DummyModule{
		logger:  logger,
		handler: h,
	}
}

// Use adds middleware(s) to the DummyModule (grouped).
func (m *DummyModule) Use(mw ...echo.MiddlewareFunc) {
	m.middlewares = append(m.middlewares, mw...)
}

// RegisterRoutes registers dummy endpoints to the given Echo group.
func (m *DummyModule) RegisterRoutes(e *echo.Group) {
	g := e.Group("/dummy", m.middlewares...)
	g.GET("", m.handler.HelloWorld)
}
